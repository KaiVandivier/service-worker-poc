/* eslint-disable no-restricted-globals */

// This service worker can be customized!
// See https://developers.google.com/web/tools/workbox/modules
// for the list of available Workbox modules, or add any other
// code you'd like.
// You can also remove this file if you'd prefer not to use a
// service worker, and the Workbox build step will be skipped.

import { clientsClaim } from 'workbox-core'
import { ExpirationPlugin } from 'workbox-expiration'
import { precacheAndRoute, createHandlerBoundToURL } from 'workbox-precaching'
import { registerRoute } from 'workbox-routing'
import { openDB } from 'idb'
import { CacheFirst } from 'workbox-strategies'
import { NetworkFirst } from 'workbox-strategies'

let dbPromise
const clientRecordingStates = {}

clientsClaim()

// Precache all of the assets generated by your build process.
// Their URLs are injected into the manifest variable below.
// This variable must be present somewhere in your service worker file,
// even if you decide not to use precaching. See https://cra.link/PWA
precacheAndRoute(self.__WB_MANIFEST)

/**
 * A test to see if another precacheAndRouteCall works (it does).
 * Limitation: files need to be explicitly specified; I haven't found
 * a way to use a glob yet.
 * Maybe this could be handled by a cache-first route? It wouldn't be precached.
 * (Cache-first route is down below)
 */
precacheAndRoute([
    { url: './vendor/jquery-3.3.1.min.js', revision: null },
    { url: 'nonexistent/url-v1.png', revision: null },
])

/**
 * (Kai: Do we need this? It might let us move away from a hash router?)
 */
// Set up App Shell-style routing, so that all navigation requests
// are fulfilled with your index.html shell. Learn more at
// https://developers.google.com/web/fundamentals/architecture/app-shell
const fileExtensionRegexp = new RegExp('/[^/?]+\\.[^/]+$')
registerRoute(
    // Return false to exempt requests from being fulfilled by index.html.
    ({ request, url }) => {
        // If this isn't a navigation, skip.
        if (request.mode !== 'navigate') {
            return false
        } // If this is a URL that starts with /_, skip.

        if (url.pathname.startsWith('/_')) {
            return false
        } // If this looks like a URL for a resource, because it contains // a file extension, skip.

        if (url.pathname.match(fileExtensionRegexp)) {
            return false
        } // Return true to signal that we want to use the handler.

        return true
    },
    createHandlerBoundToURL(process.env.PUBLIC_URL + '/index.html')
)

/**
 * Possible cache-first route for 'vendor' files, if precaching is too complicated.
 * Do we want to add i18n files here too?
 */
registerRoute(
    /(.*)\/vendor\/(.*)/,
    new CacheFirst({
        cacheName: 'vendor',
        plugins: new ExpirationPlugin({ maxAgeSeconds: 30 * 24 * 60 * 60 }), // 30 days
    })
)

/**
 * Todo: network-first, but in recording mode
 */
registerRoute(
    ({ url, request, event }) => {
        if (!isRecording(event.clientId)) return false
    },
    async ({ url, request, event, params }) => {
        // To do: handle record mode
    }
)

/**
 * Todo: network-first caching by default unless filtered out
 */
registerRoute(({ url, request, event }) => {
    // Don't cache external requests by default...
    if (url.origin !== self.location.origin) return false
    // if (url matches filter) return false
    return true
}, new NetworkFirst({ cacheName: 'app-shell', maxAgeSeconds: 30 * 24 * 60 * 60 }))

// This allows the web app to trigger skipWaiting via
// registration.waiting.postMessage({type: 'SKIP_WAITING'})
// Paired with `clientsClaim()` at top of file.
self.addEventListener('message', (event) => {
    if (event.data && event.data.type === 'SKIP_WAITING') {
        self.skipWaiting()
    }

    // TODO: Add 'start recording'
    // TODO: Add 'confirm completion'
})

// Any other custom service worker logic can go here.

// TODO: Open DB on activate
self.addEventListener('activate', (event) => {
    event.waitUntil(createDB())
})

function createDB() {
    // TODO
    // dbPromise = openDB(...)
}

function isRecording(clientId) {
    /** To do */
}

// TODO: Add rest of 'record mode' functions here